---
layout: post
title:  "허프만 알고리즘!"
---

컴퓨터에서 문자 데이터를 표현할 때는 ASCII 코드를 사용한다. ASCII 코드는 7비트 길이를 사용하는데, 문자의 빈도와 상관이 없다.

즉 각 문자는 항상 동일하게, 7비트의 길이를 사용하는 것이다. 예를 들어서 문자가 5개면 35비트를 사용하고 100개면 700비트를 사용한다.

생각해보면, 다른 문자도 있겠지만은 같은 문자가 반복적으로 사용될 수 있다. 이럴 경우에 많이 나오는 문자의 비트를 줄이고, 적게 나오는 문자의 비트를 많이 할당하면 ASCII 코드보다 비트 사용량이 줄게 될 것이다. 이러한 방법을 데이터 압축이라 부르며, 허프만 코드는 데이터 압축의 대표적인 방법이다.

 허프만 압축
- 파일의 각 문자가 8bit 아스키(ASCII)코드로 저장되면, 그 파일의 bit수는 8x(파일의 문자 수)
- 이와 같이 파일의 각 문자는 일반적으로 고정된 쿠기의 코드로 표현된다.
-> 고정된 크기의 코드로 구성된 파일을 저장하거나 전송할 때 파일의 크기를 줄이거 필요시 원해의 파일로 변환할 수 있으면 메모리 공간을 효율적으로 사용할 수 있고 파일 전송 시간을 단축 시킬 수 있다.
-> 빈번히 나타나는 문자에는 짧은 이진 코드를 할당, 드물게 나타나는 문자에는 긴 이진 코드를 할당하는 것을 허프만 압축이라고 한다.
-> 허프만 압축 방법으로 변환시킨 문자 코드들 사이에는 접두부 특성이 존재하여 특별한 구분자를 사용하지 않아도 된다.

 허프만 코드
- 입력 파일에 대해 각 문자의 출현 빈도수(문자가 파일에 나타나는 횟수)에 기반을 둔 이진트리를 만들어서, 각 문자에 이진 코드를 할당한다.
- 허프만 코드에는 우선순위 큐(최소 힙으로 구현), 최대 힙 트리 총 두가지 자룍구조가 사용된다.

 우선순위 큐
- 우선순위를 가진 항목들을 저장하는 큐
- 우선순위가 높은 데이터가 먼저 나가게 된다.
- 힙을 이용한 구현

 힙
- 완전 이진 트리
- 최대 힙, 최소 힙
- 최대 힙 = (key(부모노드) >= key(자식노드))인 완전 이진 트리
- 최소 힙 = (key(부모노드) <= key(자식노드))인 완전 이진 트리

#허프만 알고리즘 예시

-baekjoon 1931번 문제 <회의실 배정>
https://www.acmicpc.net/problem/1931

소스 코드 구현 : https://github.com/jiyeon512/computer-algorithm/blob/master/Huffman%20algorithm.h

#include <stdio.h>
#include <stdlib.h>
#include <algorithm>
#define _CRT_SECURE_NO_WARNINGS

struct arr {
	int x;
	int y;
};

arr array[100000];

bool compare(arr const &a, arr const &b) {
	if (a.y == b.y) return a.x < b.x;
	return a.y < b.y;
}

int main(void) {
	int i = 0, num = 0, x, y, cnt = 0, cur = 0;
	scanf("%d", &num);

	for(i = 0; i <num; i++) {
	scanf("%d", &x);
	scanf("%d", &y);
	array[i] = { x, y };
}

std::sort(array, array + num, compare);

for (i = 0; i < num; i++) {
	if (i == 0) {
		cnt++;
		cur = array[i].y;
	}
	else {
		if (array[i].x >= cur) {
			cnt++;
			cur = array[i].y;
		}
	}
}
printf("%d", cnt);
}

 
구현 하는 방법 : 첫 번째로 쓸 회의실이 끝나는 시간이 가장 짧은 것을 구해야 한다는 것을 파악하고 첫 번째로 쓸 회의실이 끝나는 시간이 가장 짧은 것을 구했다면 그 이후로는 그리디 알고리즘에 맞게 다음으로 짧은 것들을 구해가면 된다. 입력 받은 두 개의 시간을 배얄에 넣어서 끝나는 시간을 오름차순으로 정렬한 후 끝나는 시간과 배열의 시작하는 시간을 비교해가며 cnt를 더해주며 구현한다.
 
 

