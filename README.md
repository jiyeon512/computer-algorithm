# computer-algorithm Midterm Exam

# Ford-Fulkerson & Edmonds-Karp Algorithm

☆ What is Network flow?

그래프의 경로의 길이가 아닌, '용량'의 관점에서 바라보는 시점.

Source(시작점) -> Sink(도착점)으로 동시에 보낼 수 있는, 데이터나 사물의 최대 양을 구하는 알고리즘 (기존, 최단 거리와 같이 가장 적은 비용을 가지는 경로를 구하거나, 최단 비용을 구하는게 아니다.)

전체적으로 개념을 이해할때, network의 bandwidth로 대입하면서 생각하는게 좋다.

Ex) 인터넷으로 영화를 다운받고 있는데 파일 원격지에서 얼마나 빨리 받을 수 있는지를 알고 싶다. 각 컴퓨터의 네트워크 장비는 대역폭의 제한이 있기 때문에 가장 짧은 거리로 오는 것보다 대여곡이 큰 쪽으로 오는 것이 더 유리하다.

![image](https://user-images.githubusercontent.com/101514626/164952137-11f6c599-68b1-4b4c-a375-c55a87635368.png)

A -> B -> E의 경로에서는 최대 1의 데이터를 보낼 수 있는 반면에, A -> C -> D -> E의 경로는 한 정점을 더 지나게 되지만 한번에 100의 데이터를 보낼 수 있다.


1. 용어 정리
• Source: 시작점
• Sink: 도착점
• Capacity: 용량(간선에서 소화 가능한 최대 양 또는 값)
• Flow: 유량(간선에서 용량을 점유하고 있는, 사용하고 있는 양 또는 값)
• c(a, b): 정점 a에서 b로, 소화 가는한(남은) 용량 값
• f(a, b): 정점 a에서 b로, 사용하고 있는(쓴) 유량 값
- 이제부터는 간선의 값은 비용이 아니라 용량이 된다.
- 해당 용량을 점유하는 것(사용하는 것)을 유량이라고 표현한다.

2. 개념 설명
Network flow의 특징 3가지
• 용량의 제한
i. 각 간선에 흐르는 유량은 그 간선의 용량을 넘을 수 없다.
ii. f(a,b) <= c(a,b)

• 유량의 보존
i. 어떤 정점을 기준으로 보았을 때, 해당 정점에 (들어오는 유량의 총 합 == 나가는 유량의 총합)이어야 한다.
  ▪ e.g) a-b-c, f(a,b) == f(b,c)
  ▪ 위의 식은, 이해를 위한 단순 한줄 연결이고 실제로 a-b, a-d, a-f와 같이 복잡한 형태가 된다.
  ▪ Σf(source, x) = Σf(x, sink), x is conneted nodes
  
• 유량의 대칭
i. 네트워크 유량 알고리즘의 핵심 아이디어이다.
ii. 정점을 네트워크 공유기(혹은 스위치 등)으로 생각하면, upload, download가 발생 가능하기 때문에 역방향이 생길 수 있다는 의미의 이해가 조금이나마 도움이 된다.
iii. 이 개념의 사용을 보면서 이해를 높이는게 좋기 때문에 아래 추가적인 알고리즘 설명에서 이해를 높이고 여기서 이런 특징이 있다는 것을 알아둔다.
iv. 간선 a → b 가 있고, a → b의 capacity가 5 라면, b → a 라는 가상의 간선이 있고, 해당 간선의 capacity는 0 이라고 가정하는 것.
  ▪ 이게 되는 이유는, 실제 b → a 는 없기 때문에 capacity 을 0 (허수)로 주어서 가상의 간선을 만든것
  ▪ 즉, 1 + 2 = 3, 1 + 2 + 0 + 0 + 0 + 0 = 3, 0은 허수이기때문에 가상의 간선을 생성해도 논리적으로, 실제 결과에 영향이 없음
  ▪ f(a, b) = -f(b, a)

☆ Ford-Fulkerson Algorithm
• 최초의 네트워크 유량 알고리즘
• 개념과 구현이 간단
네트워크의 모든 간선의 유량을 0으로 시작, Source에서 Sink로 보낼 수 있는 경로로 유량을 보내기를 반복하면 된다.

중요점 - 유량의 상쇄
Ex) 최대 유향을 찾고 있는데 A-B-D로 유량을 보냈다. 알고 보니 A-B-C-D가 더 최대 유량이었기때문에 잔여 용량이 없기 때문에 더 이상 보낼 수 없고 최대값을 찾는 거에 실패를 했다.

![image](https://user-images.githubusercontent.com/101514626/164952388-3f70da9b-bd9e-4a19-beb6-7d56c276ebee.png)

위와 같은 문제점을 없애기 위해서, 유량을 보낼 때 Back-Edge를 만들어 줘야 한다.
- B->A의 용량 => c(B, A)=0, 즉 B에서 A로 보낼 수 없는 상황
- A->B로 유량을 1 보냈다고 하자. => f(A, B) = 1 = -f(B, A)
- 잔여용량 = r(B,A) = c(B,A) - f(B,A) = 0 - (-1) =1, 하나를 보낼 수 있다.
- 즉 유량 하나를 보내는 것은 역으로 유량을 하나 보낼 수 있게 해주는 작업과 같다는 말이다.

![image](https://user-images.githubusercontent.com/101514626/164952496-45549f38-6176-43c4-bf75-fc1eff96dbd2.png)

결과적으로, 모든 네트워크를 모델링 한 후에, Back Edge를 흘러가는 유량만큼 만들어 줌으로써, DFS, BFS를 가능할 때 까지 반복한다.

☆ 최소컷 최대 유향 정리(Min-cut Max-flow Theorem)
cut - Source와 Sink가 다른 집합에 속하도록 그래프의 정점들을 두 개의 집합으로 나눈 것. Source가 속한 집합을 S, Sinl가 속한 집합을 T라고 두고, S->T로 보내는 총 유량을 컷 S,T의 유향이라고 정의한다.
• cut의 중요 속성 2가지
  1. 컷의 유량은 Source->Sink의 유량과 같다.
  2. 컷의 유량 <= 컷의 용량
  ▪ 네트워크에서 용량이 가장 작은 컷을 찾아내는 문제를 최소 컷(min cut)문제라고 한다.
  ▪ 최소 컷 - 용량과 유향이 같은 컷을 찾아내면 된다.
 즉, 최소컷을 찾기 위해서는 최대 유량을 찾으면 된다.
• 구현
- 잔여 용량이 없을 때까지, 즉 보낼 수 있는 유량이 없을 때까지 BFS or DFS반복
 
