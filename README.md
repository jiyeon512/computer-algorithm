# computer-algorithm Midterm Exam

# Ford-Fulkerson Algorithm

☆ What is Network flow?

그래프의 경로의 길이가 아닌, '용량'의 관점에서 바라보는 시점.

Source(시작점) -> Sink(도착점)으로 동시에 보낼 수 있는, 데이터나 사물의 최대 양을 구하는 알고리즘 (기존, 최단 거리와 같이 가장 적은 비용을 가지는 경로를 구하거나, 최단 비용을 구하는게 아니다.)

전체적으로 개념을 이해할때, network의 bandwidth로 대입하면서 생각하는게 좋다.

Ex) 인터넷으로 영화를 다운받고 있는데 파일 원격지에서 얼마나 빨리 받을 수 있는지를 알고 싶다. 각 컴퓨터의 네트워크 장비는 대역폭의 제한이 있기 때문에 가장 짧은 거리로 오는 것보다 대여곡이 큰 쪽으로 오는 것이 더 유리하다.

![image](https://user-images.githubusercontent.com/101514626/164952137-11f6c599-68b1-4b4c-a375-c55a87635368.png)

A -> B -> E의 경로에서는 최대 1의 데이터를 보낼 수 있는 반면에, A -> C -> D -> E의 경로는 한 정점을 더 지나게 되지만 한번에 100의 데이터를 보낼 수 있다.


1. 용어 정리

• Source: 시작점

• Sink: 도착점

• Capacity: 용량(간선에서 소화 가능한 최대 양 또는 값)

• Flow: 유량(간선에서 용량을 점유하고 있는, 사용하고 있는 양 또는 값)

• c(a, b): 정점 a에서 b로, 소화 가는한(남은) 용량 값

• f(a, b): 정점 a에서 b로, 사용하고 있는(쓴) 유량 값
- 이제부터는 간선의 값은 비용이 아니라 용량이 된다.
- 해당 용량을 점유하는 것(사용하는 것)을 유량이라고 표현한다.


2. 개념 설명

Network flow의 특징 3가지

• 용량의 제한

i. 각 간선에 흐르는 유량은 그 간선의 용량을 넘을 수 없다.

ii. f(a,b) <= c(a,b)

• 유량의 보존

i. 어떤 정점을 기준으로 보았을 때, 해당 정점에 (들어오는 유량의 총 합 == 나가는 유량의 총합)이어야 한다.

▪ e.g) a-b-c, f(a,b) == f(b,c)

▪ 위의 식은, 이해를 위한 단순 한줄 연결이고 실제로 a-b, a-d, a-f와 같이 복잡한 형태가 된다.

▪ Σf(source, x) = Σf(x, sink), x is conneted nodes
  

• 유량의 대칭

i. 네트워크 유량 알고리즘의 핵심 아이디어이다.

ii. 정점을 네트워크 공유기(혹은 스위치 등)으로 생각하면, upload, download가 발생 가능하기 때문에 역방향이 생길 수 있다는 의미의 이해가 조금이나마 도움이 된다.

iii. 이 개념의 사용을 보면서 이해를 높이는게 좋기 때문에 아래 추가적인 알고리즘 설명에서 이해를 높이고 여기서 이런 특징이 있다는 것을 알아둔다.

iv. 간선 a → b 가 있고, a → b의 capacity가 5 라면, b → a 라는 가상의 간선이 있고, 해당 간선의 capacity는 0 이라고 가정하는 것.

  ▪ 이게 되는 이유는, 실제 b → a 는 없기 때문에 capacity 을 0 (허수)로 주어서 가상의 간선을 만든것

  ▪ 즉, 1 + 2 = 3, 1 + 2 + 0 + 0 + 0 + 0 = 3, 0은 허수이기때문에 가상의 간선을 생성해도 논리적으로, 실제 결과에 영향이 없음
  
  ▪ f(a, b) = -f(b, a)


☆ Ford-Fulkerson Algorithm

• 최초의 네트워크 유량 알고리즘

• 개념과 구현이 간단

네트워크의 모든 간선의 유량을 0으로 시작, Source에서 Sink로 보낼 수 있는 경로로 유량을 보내기를 반복하면 된다.

중요점 - 유량의 상쇄

Ex) 최대 유향을 찾고 있는데 A-B-D로 유량을 보냈다. 알고 보니 A-B-C-D가 더 최대 유량이었기때문에 잔여 용량이 없기 때문에 더 이상 보낼 수 없고 최대값을 찾는 거에 실패를 했다.

![image](https://user-images.githubusercontent.com/101514626/164952388-3f70da9b-bd9e-4a19-beb6-7d56c276ebee.png)

위와 같은 문제점을 없애기 위해서, 유량을 보낼 때 Back-Edge를 만들어 줘야 한다.

- B->A의 용량 => c(B, A)=0, 즉 B에서 A로 보낼 수 없는 상황

- A->B로 유량을 1 보냈다고 하자. => f(A, B) = 1 = -f(B, A)

- 잔여용량 = r(B,A) = c(B,A) - f(B,A) = 0 - (-1) =1, 하나를 보낼 수 있다.

- 즉 유량 하나를 보내는 것은 역으로 유량을 하나 보낼 수 있게 해주는 작업과 같다는 말이다.

![image](https://user-images.githubusercontent.com/101514626/164952496-45549f38-6176-43c4-bf75-fc1eff96dbd2.png)

결과적으로, 모든 네트워크를 모델링 한 후에, Back Edge를 흘러가는 유량만큼 만들어 줌으로써, DFS, BFS를 가능할 때 까지 반복한다.


☆ 최소컷 최대 유향 정리(Min-cut Max-flow Theorem)

cut - Source와 Sink가 다른 집합에 속하도록 그래프의 정점들을 두 개의 집합으로 나눈 것. Source가 속한 집합을 S, Sinl가 속한 집합을 T라고 두고, S->T로 보내는 총 유량을 컷 S,T의 유향이라고 정의한다.
 
 • cut의 중요 속성 2가지
 
  1. 컷의 유량은 Source->Sink의 유량과 같다.
  
  2. 컷의 유량 <= 컷의 용량
  
  ▪ 네트워크에서 용량이 가장 작은 컷을 찾아내는 문제를 최소 컷(min cut)문제라고 한다.
  
  ▪ 최소 컷 - 용량과 유향이 같은 컷을 찾아내면 된다.
 
 즉, 최소컷을 찾기 위해서는 최대 유량을 찾으면 된다.

• 구현

- 잔여 용량이 없을 때까지, 즉 보낼 수 있는 유량이 없을 때까지 BFS or DFS반복
 

☆ 알고리즘 설명

- 네트워크 유량의 가장 기본적인 알고리즘은, Ford-Fulkerson Algorithmm과 Edmonds-Karp Algorithm이 있습니다.

- 기본적으로 두개의 알고리즈은, brute force algorithm의 특성을 가집니다. 두 알고리즘 모두 아래와 같은 형태의 동작원리를 가지게 됩니다.

1. Source에서 Sink로 가는 경로를 하나 찾습니다.

• 이때 해당 경로는 반드시 여유 용량이 남아 있어야 합니다. 즉 c(a,b) - f(a,b) > 0

2. 찾아낸 경로에 보낼 수 있는 flow을 찾습니다. 보낼 수 있는 최대 flow는 경로에 남은 capacity의 최소값입니다.

• 현재 찾아낸 경로에서 보낼 수 있는 가능한 최대의 flow 값(유량값)은, 경로에 남은 capacity의 최소값이 됩니다. 경로상 Min(c(a,b) - f(a,b))

3. 찾아낸 경로에, 찾아낸 최대 flow을 실제 흘려보냅니다.

• 전체 경로에 f(a,b) += flow을 하게 됩니다.

  ▪ e.g) a - b - c - d 와 같은 경로라면, f(a,b) += flow, f(b,c) += flow, f(c,d) += flow 을 해줍니다.
  
• 동시에 '유량의 대칭'조건에 따라서, 역방향 역시 flow을 음수값으로 흘려 보냅니다.

  ▪ e.g) a - b - c- d 와 같은 경로라면, f(b,a) -= flow, f(c,b) -= flow, f(d,c) -= flow을 해줍니다.
  
  ▪ 이게 되는 이유는, 가상의 역방향 간선의 capacity는 서살 0이고, 해당 capacity에 -값으로 flow(유량)을 흘려도, 용량의 제한 조건을 넘지 않습니다.
  
  ▪ f(b,a) -= flow 일때, 즉 -1(flow) / 0(capacity)형태이고, 이는 c(b,a) - f(b,a) > 0, (0-(-1)) = 1이니깐 조건을 만족합니다.
  
 4. 1번에 해당하는 경로 찾기가 실패하기 전까지 위 1~3번을 반복합니다.


☆ 포드-풀커슨 최악의 케이스

![image](https://user-images.githubusercontent.com/101514626/164955344-53d4e602-4a97-4b7b-8472-8da0a1934a8a.png)

위와 같은 그래프가 있다고 가정합니다.

이때 네트워크 알고리즘을 사용하되, 포드-풀커슨을 구현했다고 봅니다.

![image](https://user-images.githubusercontent.com/101514626/164955370-48c32743-380e-4cfe-be66-00ae53b765a5.png)

처음 A -> B -> C -> D 경로를 찾고, flow1을 흘려보냅니다.

![image](https://user-images.githubusercontent.com/101514626/164955386-a34f5f4a-45e6-4130-a015-07840df20212.png)

역간선을 이용해서 A -> C -> B -> D 의 경로가 찾아집니다.

DFS구형산 A -> B -> C에서 막히고, A -> C -> B -> D의 경로가 찾아집니다.

이제 A -> C -> B -> D로 flow 1을 흘려 보냅니다. B -> C는 역간선 C -> B에서 flow가 흐를대 -1이 되어 0/1로 초기화 되었습니다.

그럼 이제 다시 처음 A -> B -> C -> D의 경로가 됩니다.

결국 1000번의 루플 타게 되고 

![image](https://user-images.githubusercontent.com/101514626/164955501-41634225-c607-4e87-a264-2165e433777e.png)

최종 답이 나오게 됩니다.

결국 포드-풀커슨 형태로 경로를 탐색하게 되면, 최악의 경우 flow의 max수치 (위 예제에서는, 1000)만큼 루프를 반복하게 됩니다.

시간복잡도가 결국, O(V+E)F 형태가 됩니다.
