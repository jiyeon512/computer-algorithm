# computer-algorithm Midterm Exam

# Ford-Fulkerson Algorithm

☆ What is Network flow?

그래프의 경로의 길이가 아닌, '용량'의 관점에서 바라보는 시점.

Source(시작점) -> Sink(도착점)으로 동시에 보낼 수 있는, 데이터나 사물의 최대 양을 구하는 알고리즘 (기존, 최단 거리와 같이 가장 적은 비용을 가지는 경로를 구하거나, 최단 비용을 구하는게 아니다.)

전체적으로 개념을 이해할때, network의 bandwidth로 대입하면서 생각하는게 좋다.

Ex) 인터넷으로 영화를 다운받고 있는데 파일 원격지에서 얼마나 빨리 받을 수 있는지를 알고 싶다. 각 컴퓨터의 네트워크 장비는 대역폭의 제한이 있기 때문에 가장 짧은 거리로 오는 것보다 대여곡이 큰 쪽으로 오는 것이 더 유리하다.

![image](https://user-images.githubusercontent.com/101514626/164952137-11f6c599-68b1-4b4c-a375-c55a87635368.png)

A -> B -> E의 경로에서는 최대 1의 데이터를 보낼 수 있는 반면에, A -> C -> D -> E의 경로는 한 정점을 더 지나게 되지만 한번에 100의 데이터를 보낼 수 있다.


1. 용어 정리

• Source: 시작점

• Sink: 도착점

• Capacity: 용량(간선에서 소화 가능한 최대 양 또는 값)

• Flow: 유량(간선에서 용량을 점유하고 있는, 사용하고 있는 양 또는 값)

• c(a, b): 정점 a에서 b로, 소화 가는한(남은) 용량 값

• f(a, b): 정점 a에서 b로, 사용하고 있는(쓴) 유량 값
- 이제부터는 간선의 값은 비용이 아니라 용량이 된다.
- 해당 용량을 점유하는 것(사용하는 것)을 유량이라고 표현한다.


2. 개념 설명

Network flow의 특징 3가지

• 용량의 제한

i. 각 간선에 흐르는 유량은 그 간선의 용량을 넘을 수 없다.

ii. f(a,b) <= c(a,b)

• 유량의 보존

i. 어떤 정점을 기준으로 보았을 때, 해당 정점에 (들어오는 유량의 총 합 == 나가는 유량의 총합)이어야 한다.

▪ e.g) a-b-c, f(a,b) == f(b,c)

▪ 위의 식은, 이해를 위한 단순 한줄 연결이고 실제로 a-b, a-d, a-f와 같이 복잡한 형태가 된다.

▪ Σf(source, x) = Σf(x, sink), x is conneted nodes
  

• 유량의 대칭

i. 네트워크 유량 알고리즘의 핵심 아이디어이다.

ii. 정점을 네트워크 공유기(혹은 스위치 등)으로 생각하면, upload, download가 발생 가능하기 때문에 역방향이 생길 수 있다는 의미의 이해가 조금이나마 도움이 된다.

iii. 이 개념의 사용을 보면서 이해를 높이는게 좋기 때문에 아래 추가적인 알고리즘 설명에서 이해를 높이고 여기서 이런 특징이 있다는 것을 알아둔다.

iv. 간선 a → b 가 있고, a → b의 capacity가 5 라면, b → a 라는 가상의 간선이 있고, 해당 간선의 capacity는 0 이라고 가정하는 것.

  ▪ 이게 되는 이유는, 실제 b → a 는 없기 때문에 capacity 을 0 (허수)로 주어서 가상의 간선을 만든것

  ▪ 즉, 1 + 2 = 3, 1 + 2 + 0 + 0 + 0 + 0 = 3, 0은 허수이기때문에 가상의 간선을 생성해도 논리적으로, 실제 결과에 영향이 없음
  
  ▪ f(a, b) = -f(b, a)



☆ Ford-Fulkerson Algorithm

• 최초의 네트워크 유량 알고리즘

• 개념과 구현이 간단

네트워크의 모든 간선의 유량을 0으로 시작, Source에서 Sink로 보낼 수 있는 경로로 유량을 보내기를 반복하면 된다.

중요점 - 유량의 상쇄

Ex) 최대 유향을 찾고 있는데 A-B-D로 유량을 보냈다. 알고 보니 A-B-C-D가 더 최대 유량이었기때문에 잔여 용량이 없기 때문에 더 이상 보낼 수 없고 최대값을 찾는 거에 실패를 했다.

![image](https://user-images.githubusercontent.com/101514626/164952388-3f70da9b-bd9e-4a19-beb6-7d56c276ebee.png)

위와 같은 문제점을 없애기 위해서, 유량을 보낼 때 Back-Edge를 만들어 줘야 한다.

- B->A의 용량 => c(B, A)=0, 즉 B에서 A로 보낼 수 없는 상황

- A->B로 유량을 1 보냈다고 하자. => f(A, B) = 1 = -f(B, A)

- 잔여용량 = r(B,A) = c(B,A) - f(B,A) = 0 - (-1) =1, 하나를 보낼 수 있다.

- 즉 유량 하나를 보내는 것은 역으로 유량을 하나 보낼 수 있게 해주는 작업과 같다는 말이다.

![image](https://user-images.githubusercontent.com/101514626/164952496-45549f38-6176-43c4-bf75-fc1eff96dbd2.png)

결과적으로, 모든 네트워크를 모델링 한 후에, Back Edge를 흘러가는 유량만큼 만들어 줌으로써, DFS, BFS를 가능할 때 까지 반복한다.



☆ 최소컷 최대 유향 정리(Min-cut Max-flow Theorem)

cut - Source와 Sink가 다른 집합에 속하도록 그래프의 정점들을 두 개의 집합으로 나눈 것. Source가 속한 집합을 S, Sinl가 속한 집합을 T라고 두고, S->T로 보내는 총 유량을 컷 S,T의 유향이라고 정의한다.
 
 • cut의 중요 속성 2가지
 
  1. 컷의 유량은 Source->Sink의 유량과 같다.
  
  2. 컷의 유량 <= 컷의 용량
  
  ▪ 네트워크에서 용량이 가장 작은 컷을 찾아내는 문제를 최소 컷(min cut)문제라고 한다.
  
  ▪ 최소 컷 - 용량과 유향이 같은 컷을 찾아내면 된다.
 
 즉, 최소컷을 찾기 위해서는 최대 유량을 찾으면 된다.

• 구현

- 잔여 용량이 없을 때까지, 즉 보낼 수 있는 유량이 없을 때까지 BFS or DFS반복
 


☆ 알고리즘 설명

- 네트워크 유량의 가장 기본적인 알고리즘은, Ford-Fulkerson Algorithmm과 Edmonds-Karp Algorithm이 있습니다.

- 기본적으로 두개의 알고리즈은, brute force algorithm의 특성을 가집니다. 두 알고리즘 모두 아래와 같은 형태의 동작원리를 가지게 됩니다.

1. Source에서 Sink로 가는 경로를 하나 찾습니다.

• 이때 해당 경로는 반드시 여유 용량이 남아 있어야 합니다. 즉 c(a,b) - f(a,b) > 0

2. 찾아낸 경로에 보낼 수 있는 flow을 찾습니다. 보낼 수 있는 최대 flow는 경로에 남은 capacity의 최소값입니다.

• 현재 찾아낸 경로에서 보낼 수 있는 가능한 최대의 flow 값(유량값)은, 경로에 남은 capacity의 최소값이 됩니다. 경로상 Min(c(a,b) - f(a,b))

3. 찾아낸 경로에, 찾아낸 최대 flow을 실제 흘려보냅니다.

• 전체 경로에 f(a,b) += flow을 하게 됩니다.

  ▪ e.g) a - b - c - d 와 같은 경로라면, f(a,b) += flow, f(b,c) += flow, f(c,d) += flow 을 해줍니다.
  
• 동시에 '유량의 대칭'조건에 따라서, 역방향 역시 flow을 음수값으로 흘려 보냅니다.

  ▪ e.g) a - b - c- d 와 같은 경로라면, f(b,a) -= flow, f(c,b) -= flow, f(d,c) -= flow을 해줍니다.
  
  ▪ 이게 되는 이유는, 가상의 역방향 간선의 capacity는 서살 0이고, 해당 capacity에 -값으로 flow(유량)을 흘려도, 용량의 제한 조건을 넘지 않습니다.
  
  ▪ f(b,a) -= flow 일때, 즉 -1(flow) / 0(capacity)형태이고, 이는 c(b,a) - f(b,a) > 0, (0-(-1)) = 1이니깐 조건을 만족합니다.
  
 4. 1번에 해당하는 경로 찾기가 실패하기 전까지 위 1~3번을 반복합니다.



☆ 포드-풀커슨 최악의 케이스

![image](https://user-images.githubusercontent.com/101514626/164955344-53d4e602-4a97-4b7b-8472-8da0a1934a8a.png)

위와 같은 그래프가 있다고 가정합니다.

이때 네트워크 알고리즘을 사용하되, 포드-풀커슨을 구현했다고 봅니다.

![image](https://user-images.githubusercontent.com/101514626/164955370-48c32743-380e-4cfe-be66-00ae53b765a5.png)

처음 A -> B -> C -> D 경로를 찾고, flow1을 흘려보냅니다.

![image](https://user-images.githubusercontent.com/101514626/164955386-a34f5f4a-45e6-4130-a015-07840df20212.png)

역간선을 이용해서 A -> C -> B -> D 의 경로가 찾아집니다.

DFS구형산 A -> B -> C에서 막히고, A -> C -> B -> D의 경로가 찾아집니다.

이제 A -> C -> B -> D로 flow 1을 흘려 보냅니다. B -> C는 역간선 C -> B에서 flow가 흐를대 -1이 되어 0/1로 초기화 되었습니다.

그럼 이제 다시 처음 A -> B -> C -> D의 경로가 됩니다.

결국 1000번의 루플 타게 되고 

![image](https://user-images.githubusercontent.com/101514626/164955501-41634225-c607-4e87-a264-2165e433777e.png)

최종 답이 나오게 됩니다.

결국 포드-풀커슨 형태로 경로를 탐색하게 되면, 최악의 경우 flow의 max수치 (위 예제에서는, 1000)만큼 루프를 반복하게 됩니다.

시간복잡도가 결국, O(V+E)F 형태가 됩니다.



☆ 추가적으로

- 만약 문제에서 역방향 간선 자체가 입력으로 주어진 경우는 어떻게 해야할까?

![image](https://user-images.githubusercontent.com/101514626/164955962-43f1d294-ccd5-4f45-b6e6-8265406e6303.png)

• A -> B, 3 B -> A, 5

위와 같은 형태로 입려값이 주어진다면, A -> B 입력에 대한 역방향 간선(허수 간선) B -> A가 용량 0으로 있어야 하는데, 실제 B -> A 입력 때문에 허수가 아닌 실제값을 가지는 간선 B -> A가 있게 된다.

역방향 간선은 허수값을 용량으로(capacity)가는 형태가 되어야 하는데, 문제 자체에서 반대 방향을 Input으로 주어서 capacity가 실제 값을 가지는 형태가 된다. 그럼 최초와 같이 brute force algorithm 형태에서 못찾는 경로가 발생 할 수 있다.

- 어떻게 해야 할까?

이런 경우는 가상의 정점을 하나 두고 해당, 정점을 거쳐서 가는 현태로 바꾸어 주면 된다.

네트워크 유량의 특성(용량의 제한, 유량의 보존)을 만족시키기 때문에 문제가 없다.

![image](https://user-images.githubusercontent.com/101514626/164956130-9ad8a43c-f0f4-4310-8440-b2312cfc1b48.png)

- 만약 문제에서 같은 방향의 간선이 여러개 입력으로 주어진 경운,ㄴ?

• A -> B, 3 A -> B, 4 A -> B, 2

동일한 방향의 간선이라면, 사실 하나의 간선에 용량을 모두 더해서 생각하면 된다.

![image](https://user-images.githubusercontent.com/101514626/164956183-d7bcb89c-bd88-4a5a-85a8-8a23552020de.png)



☆ 정리
이것으로 흐름 네트워크에서 최대 흐름을 찾는 방법인 포드-풀커슨 방법에 대해서 알아 보았습니다. 

정리하자면, 포드-풀커슨 방법은 무한한 용량을 갖는 간선이나 유리수 용량 갖는 간선이 있을 때까지는 문제 없이 최대 흐름을 찾아줄 수 있지만, 간선의 용량에 무리수를 허용하는 경우에는 제대로 동작하지 않을 수 있습니다.
 

사실, 무리수의 용량을 가정하는 것은 약간 무리가 따르기도 합니다. 

왜냐하면 컴퓨터는 결국 셀 수 있는(countable) 것들만 제대로 표현할 수 있기 때문입니다. 실례로 컴퓨터가 0과 1사이의 모든 실수를 절대로 표현할 수 없다는 것은 잘 알려진 사실입니다. 때문에 많은 경우 우리는 입력을 유리수로 한정하는 경우가 많습니다. 그럼에도 혹여나 무리수를 제대로 다룰 수 있는 컴퓨터가 있다고 가정했을 때 여전히 최대 흐름 문제를 잘 해결하는 방법이 있는지 궁금하실 겁니다.

 
수행 시간도 큰 문제입니다. 이 방법은 유한의 정수만 입력받은 때에도 최악의 경우 입력의 지수 시간동안 동작했습니다. 이와 같은 상황들이 발생하게 된 가장 큰 이유는 증가 경로 를 아무거나 고를 수 있었기 때문입니다. 이 때문에 많은 사람들이 포드-풀커슨 방법을 '알고리즘(algorithm)' 대신 '방법(method)'이라고 부릅니다.


☆ baekjoon 11375번 문제: https://www.acmicpc.net/problem/11375

- 문제 해결 소스코드: https://github.com/jiyeon512/computer-algorithm/blob/master/Ford-Fulkerson_baekjoon11375.c
