---
layout: post
title:  "제목!"
---

#동적 계획법과 분할 정복

1. 정의

동적 계획법(DP라고 많이 부름)

- 입력 크기가 작은 부분 문제들을 해결한 후, 해당 부분 문제의 해를 활용해서, 보다 큰 크기의 부분 문제를 해결, 최종적으로 전체 문제를 해결하는 알고리즘

- 상향식 접근법으로, 가장 최하위 해답을 구한 후, 이를 저장하고 해당 결과값을 이용해서 상위 문제를풀어가는 방식

​- Memoization 기법을 사용

- Memoization: 프로그램 실행 시 이전에 계산한 값을 저장해, 다시 계산하지 않도록 해 전체 실행 속도를 향상시키는 기술

​- 문제를 잘게 쪼갤 때, 부분 문제는 중복되어 재활용됨

- 예: 피보나치 수열

​

분할 정복

​- 문제를 나눌 수 없을 때까지 나누어서 각각을 풀면서 다시 합병하여 문제의 답을 얻는 알고리즘

​- 하향식 접근법으로, 상위의 해답을 구하기 위해 아래로 내려가면서 하위의 해답을 구하는 방식

- 일반적으로 재귀함수로 표현

​- 문제를 잘게 쪼갤 때, 부분 문제는 서로 중복되지 않음

- 예: 병합 정렬, 퀵 정렬

​

2. 공통점

- 문제를 잘게 쪼개서, 가장 작은 단위로 분할

​
3. 차이점

- 동적 계획법

- 부분 문제는 중복되어, 상위 문제 해결 시 재활용됨

- Memoization 기법 사용(부분 문제의 해답을 저장해서 재활용하는 최적화 기법으로 사용)

- 반복적으로 동작하는 구조가 보일때(점화식 같은) 접근

​

- 분할 정복

- 부분 문제는 서로 중복되지 않음

- Memoization 기법 사용 안 함

- 찢어가며 하나 하나씩 해결해나간다.



4. 동적 계획법 예시 

- baekjoon 9461번 문제 <파도반 수열>
https://www.acmicpc.net/problem/9461


#include <stdio.h> 

int main() { 	
int T, num, i; 	
long long temp; 	
scanf("%d", &T); 	
while (T <= 100 && T-- > 0) 	
{ 		
long long arr[5] = { 1, 1, 1, 2, 2 }; 		scanf("%d", &num); 		
if (num <= 5) 			
printf("%lld\n", arr[num - 1]); 		
else { 			
i = 5; 			
while (++i <= num) { 				
temp = arr[(i - 1) % 5] + arr[(i - 2) % 5]; 				arr[(i - 1) % 5] = temp; 			
} 			
printf("%lld\n", temp); 		
} 	
} 	
return 0; 
}



여기 문제에서의 규칙은 arr[N] = arr[N - 1] + arr[N - 5] 의 값인 구조인데, 배열로 값을 저장하지 않고 코드를 구현했다.
